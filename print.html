<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>discord.py-by-examples</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_0_configuration/bot_configuration.html"><strong aria-hidden="true">2.</strong> Bot Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_0_configuration/first_bot.html"><strong aria-hidden="true">2.1.</strong> First Bot</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_1_events/events.html"><strong aria-hidden="true">3.</strong> Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_events/how_events_work.html"><strong aria-hidden="true">3.1.</strong> How Events Work</a></li><li class="chapter-item expanded "><a href="chapter_1_events/on_ready_event.html"><strong aria-hidden="true">3.2.</strong> on_ready event</a></li><li class="chapter-item expanded "><a href="chapter_1_events/on_message_event.html"><strong aria-hidden="true">3.3.</strong> on_message event</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2_commands/commands.html"><strong aria-hidden="true">4.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2_commands/creating_a_command.html"><strong aria-hidden="true">4.1.</strong> Creating a Command</a></li><li class="chapter-item expanded "><a href="chapter_2_commands/single_argument_commands.html"><strong aria-hidden="true">4.2.</strong> Single argument commands</a></li><li class="chapter-item expanded "><a href="chapter_2_commands/multiple_argument_commands.html"><strong aria-hidden="true">4.3.</strong> Multiple argument commands</a></li><li class="chapter-item expanded "><a href="chapter_2_commands/string_argument_in_commands.html"><strong aria-hidden="true">4.4.</strong> String argument in commands</a></li><li class="chapter-item expanded "><a href="chapter_2_commands/unlimited_arguments_in_commands.html"><strong aria-hidden="true">4.5.</strong> Unlimited arguments in commands</a></li><li class="chapter-item expanded "><a href="chapter_2_commands/commands_error_handling.html"><strong aria-hidden="true">4.6.</strong> Commands error handling</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3_basic_converters/basic_converters.html"><strong aria-hidden="true">5.</strong> Converters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3_basic_converters/basic_converter.html"><strong aria-hidden="true">5.1.</strong> Basic Converter</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_4_cogs/cogs.html"><strong aria-hidden="true">6.</strong> Cogs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4_cogs/advanced_bot_setup.html"><strong aria-hidden="true">6.1.</strong> Advanced Bot Setup</a></li><li class="chapter-item expanded "><a href="chapter_4_cogs/how_cogs_work.html"><strong aria-hidden="true">6.2.</strong> How Cogs Work</a></li><li class="chapter-item expanded "><a href="chapter_4_cogs/commands_in_cogs.html"><strong aria-hidden="true">6.3.</strong> Commands in Cogs</a></li><li class="chapter-item expanded "><a href="chapter_4_cogs/events_in_cogs.html"><strong aria-hidden="true">6.4.</strong> Events in Cogs</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_5_embeds/embeds.html"><strong aria-hidden="true">7.</strong> Embeds</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5_embeds/how_embeds_work.html"><strong aria-hidden="true">7.1.</strong> How Embeds Work</a></li><li class="chapter-item expanded "><a href="chapter_5_embeds/embeds_configuration.html"><strong aria-hidden="true">7.2.</strong> Embeds Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6_slash_commands/slash_commands.html"><strong aria-hidden="true">8.</strong> Slash Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_6_slash_commands/slash_commands.html"><strong aria-hidden="true">8.1.</strong> Slash Commands</a></li><li class="chapter-item expanded "><a href="chapter_6_slash_commands/slash_commands_in_cogs.html"><strong aria-hidden="true">8.2.</strong> Slash Commands in Cogs</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_7_hybrid_commands/hybrid_commands.html"><strong aria-hidden="true">9.</strong> Hybrid Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_7_hybrid_commands/hybrid_commands.html"><strong aria-hidden="true">9.1.</strong> Hybrid Commands</a></li><li class="chapter-item expanded "><a href="chapter_7_hybrid_commands/hybrid_commands_in_cogs.html"><strong aria-hidden="true">9.2.</strong> Hybrid Commands in Cogs</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_8_converters/converters.html"><strong aria-hidden="true">10.</strong> Converters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_8_converters/function_converter.html"><strong aria-hidden="true">10.1.</strong> Function Converter</a></li><li class="chapter-item expanded "><a href="chapter_8_converters/advanced_converter.html"><strong aria-hidden="true">10.2.</strong> Advanced Converter</a></li><li class="chapter-item expanded "><a href="chapter_8_converters/discord_converters.html"><strong aria-hidden="true">10.3.</strong> Discord Converters</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">discord.py-by-examples</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome in discord.py-by-example! This book is a collection of examples of how to use the discord.py library. It is meant to be used as a reference book, so you can read the chapters in any order you want. However, I recommend you to read the chapters in the order they are presented, as some chapters may require knowledge from previous chapters.</p>
<p>If you want to contribute to this book, you can do so by creating a pull request on The GitHub repository of this book. You can also create an issue if you find a mistake or if you want to suggest a new chapter.</p>
<p>If you have any question, you can DM me at <code>@AliBen#7502</code> on Discord or create an issue on the GitHub repository of this book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bot-configuration"><a class="header" href="#bot-configuration">Bot Configuration</a></h1>
<p>The first step in the bot creation is to configure the bot. First we need to create a new application in developer portal. To do that, go to <a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a> and click on &quot;New Application&quot;. Then, you need to give a name to your application and click on &quot;Create&quot;.</p>
<p>Now, you can see the dashboard of your application. In this dashboard, you can see the client ID of your application, the client secret and the bot token. The bot token is the most important thing here. This token is used to connect your bot to Discord. <strong>Never share this token with anyone</strong>. </p>
<p>If someone has this token, he can do anything with your bot. If you think that someone has your token, you can regenerate it by clicking on &quot;Regenerate&quot; in the bot section of the dashboard.</p>
<p>Once you have your bot token, you can invite your bot to your server. To do that, go to the OAuth2 section of the dashboard. In the &quot;Scopes&quot; section, select &quot;bot&quot;. Then, in the &quot;Bot Permissions&quot; section, select the permissions that your bot will need. </p>
<p>For example, if you want to create a bot that will send messages, you need to select the &quot;Send Messages&quot; permission. Once you have selected the permissions, you can copy the link in the &quot;Scopes&quot; section and paste it in your browser. Then, you can select the server where you want to invite your bot and click on &quot;Continue&quot;. Finally, click on &quot;Authorize&quot; to invite your bot to your server.</p>
<p>Now we need to download the discord.py library. To do that, open a terminal and type <code>pip install discord.py</code>. Once the library is installed, we can start coding our bot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-bot"><a class="header" href="#first-bot">First Bot</a></h1>
<p>To create a new Bot, we just need to create a new instance of the <code>commands.Bot</code> class. This class will take two mandatory arguments: <code>command_prefix</code> and <code>intents</code>.</p>
<ul>
<li><code>command_prefix</code> is the prefix that will be used to invoke the commands. For example, if the prefix is <code>!</code>, then the command <code>!ping</code> will be invoked by typing <code>!ping</code> in the chat.</li>
<li><code>intents</code> is a class that represents the events that the bot will be able to receive. For example, if we want to receive the <code>on_message</code> event, we need to pass the <code>discord.Intents.messages</code> class.</li>
</ul>
<pre><code class="language-py">import discord
from discord.ext import commands

bot = commands.Bot(command_prefix=&quot;!&quot;, intents=discord.Intents.all())
</code></pre>
<p>In this example, we are passing the <code>discord.Intents.all()</code> class, which represents all the intents. This is not recommended, as it can cause performance issues. Instead, we should only pass the intents that we need. For example, if we only need the <code>on_message</code> event, we can pass the <code>discord.Intents.messages</code> class.</p>
<pre><code class="language-py">import discord
from discord.ext import commands

bot = commands.Bot(command_prefix=&quot;!&quot;, intents=discord.Intents.messages())
</code></pre>
<h2 id="running-the-bot"><a class="header" href="#running-the-bot">Running the Bot</a></h2>
<p>To run the bot we need to use the <code>run</code> method of the <code>commands.Bot</code> class. This method takes one mandatory argument: <code>token</code>. This is the token of the bot that we want to run. We can get this token from the <a href="https://discord.com/developers/applications">Discord Developer Portal</a>. For more information about the loading state of the bot we will create a new <em>event</em> <code>on_ready</code> (see <a href="chapter_0_configuration/.././chapter_1_events/on_ready_event.html">on_ready event</a>).</p>
<pre><code class="language-py">import discord
from discord.ext import commands

bot = commands.Bot(command_prefix=&quot;!&quot;, intents=discord.Intents(messages=True))

@bot.event
async def on_ready():
    print(&quot;Bot is ready&quot;)


bot.run(&quot;token&quot;) # Replace token with your bot's token
</code></pre>
<p>For more security, we can store the token in a file called <code>.env</code> and load it using the <code>dotenv</code> module. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>Events are a key concept in the <strong>discord.py</strong> library. They are used to detect when something happens in the Discord server, such as a new message being sent or a member joining the server. In this chapter, we will learn how to use events in our bots.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-events-work"><a class="header" href="#how-events-work">How Events Work</a></h1>
<h2 id="what-are-events"><a class="header" href="#what-are-events">What are events?</a></h2>
<p>An event is a type of function that triggers every time a specific action is performed. The behavior of this function will depend on the event that is created. For example, there is an event that triggers as soon as the Bot is started or another event that triggers with every new message. The structure of an event is as follows:</p>
<pre><code class="language-python">@bot_name.event
async def event_name(param1, ..., paramN):
    ...
</code></pre>
<p>In this example, <code>bot_name</code> represents the name of the variable containing the <code>commands.Bot</code> object. The <code>event</code> method of this class is called as a decorator to convert the following function into an event. The name of the event is represented by <code>event_name</code>, which will be different for each created event. The function's parameters are specific to each created event (to know all the events, refer to the documentation). In summary, events are very useful for managing Discord-specific actions that are outside the control of the bot. You can find all events <a href="https://discordpy.readthedocs.io/en/stable/api.html#event-reference">here</a>.</p>
<h2 id="how-to-use-events"><a class="header" href="#how-to-use-events">How to use events</a></h2>
<p>To use an event, we need to create a function with the <code>bot_name.event</code> decorator. For example, if we want to use the <code>on_ready</code> event, we need to create a function with the <code>bot_name.event</code> decorator and pass the <code>on_ready</code> event as an argument. This function will be called when the <code>on_ready</code> event is called. For example, if we want to print a message when the <code>on_ready</code> event is called, we can do this:</p>
<pre><code class="language-py">@bot.event
async def on_ready():
    print(&quot;Bot is ready&quot;)
</code></pre>
<p>Now each time the bot load we will have the following output:</p>
<pre><code class="language-md">&gt;&gt;&gt; Bot is ready
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on_ready-event"><a class="header" href="#on_ready-event">on_ready event</a></h1>
<p>The <code>on_ready</code> event is called when the bot is online and ready to receive events. This event is called only once, when the bot is ready. This event takes no arguments and need to be created like this:</p>
<pre><code class="language-py">@bot.event
async def on_ready():
    print(&quot;Bot is ready&quot;)
</code></pre>
<p>In this example, we are printing a message when the <code>on_ready</code> event is called. So every time the bot is ready, the message <code>Bot is ready</code> will be printed in the console. So if we run the bot, we will have the following output:</p>
<pre><code class="language-md">&gt;&gt;&gt; Bot is ready
</code></pre>
<p>This event is very useful for knowing when the bot is ready to receive events but useless for all other cases. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="on_message-event"><a class="header" href="#on_message-event">on_message event</a></h1>
<p>The <code>on_message</code> event is called when a message is sent in a channel that the bot can see. This event takes a <code>message</code> of type <code>discord.Message</code> as an argument and need to be created like this:</p>
<pre><code class="language-py">@bot.event
async def on_message(message : discord.Message):
    print(message.content)
</code></pre>
<p>With this event we can for example create a command that will send a message when a user sends a specific message. For example, if we want to send &quot;Hello!&quot; when a user sends &quot;Hi&quot;, we can do this:</p>
<pre><code class="language-py">@bot.event
async def on_message(message : discord.Message):
    if message.author.bot:
        return

    if message.content == &quot;Hi&quot;:
        await message.channel.send(&quot;Hello!&quot;)
</code></pre>
<p>In this example, we are checking if the message is sent by a bot. If it is, we return (This is used to avoid the bot to reply to itself and creating an infinite loop). Then we are checking if the message content is &quot;Hi&quot;. If it is, we are sending &quot;Hello!&quot; in the channel where the message was sent. </p>
<p>To check if the message content is &quot;Hi&quot;, we are using the <code>content</code> attribute of the <code>discord.Message</code> class. This attribute returns the content of the message as a string. To send a message in a channel, we are using the <code>send</code> method of the <code>discord.TextChannel</code> class. This method takes one mandatory argument: <code>content</code>. This is the content of the message that will be sent.</p>
<p>This method returns a <code>discord.Message</code> object that represents the message that was sent. We are using the <code>await</code> keyword before the <code>send</code> method because this method is a coroutine. For more information about coroutines, see <a href="https://docs.python.org/3/library/asyncio-task.html#coroutine">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Commands are the main reason why we use <em>discord.py</em>. They are the main way to interact with the bot. In this chapter, we will learn how to create commands, how to use them based on their parameters, and how to handle errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-command"><a class="header" href="#creating-a-command">Creating a Command</a></h1>
<p>To create a new commande we need to create a function with the decorator <code>bot_name.command()</code> where <code>bot_name</code> is the name of the bot. Each command will have the following structure:</p>
<pre><code class="language-py">@bot_name.command()
async def command_name(ctx : commands.Context, arg1, arg2, ...):
    # Code
</code></pre>
<p>The first argument of this command is the <em>context</em> of the command. This argument is mandatory and need to be named <code>ctx</code> as convention. This argument is of type <code>commands.Context</code>and it contains all the information about the command. For others arguments, you can add as many as you want, there are just some rules to follow with strings that will be explained later.</p>
<p>For example, if we want to create a command that will send &quot;Hello, World!&quot; when a user sends &quot;!hello&quot;, we can do this:</p>
<pre><code class="language-py">@bot.command()
async def hello(ctx : commands.Context):
    await ctx.send(&quot;Hello, World!&quot;)
</code></pre>
<p>To call this command, we need to send &quot;!hello&quot; (If the current prefix is &quot;!&quot; else change this with your prefix) in a channel where the bot can see. So the final code will be:</p>
<pre><code class="language-py">&gt;&gt;&gt; !hello
Hello, World!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-argument-commands"><a class="header" href="#single-argument-commands">Single argument commands</a></h1>
<p>To create a command with an unique argument, we need to add an argument to the function. This argument can be of any type. For example if we want to create a command that takes an integer <code>n</code> as argument and send the number from 1 to <code>n</code>, we can do this:</p>
<pre><code class="language-py">@bot.command()
async def count(ctx : commands.Context, n : int):
    for i in range(1, n + 1):
        await ctx.send(i)
</code></pre>
<p>To call this command, we need to send &quot;!count 10&quot; (If the current prefix is &quot;!&quot; else change this with your prefix) in a channel where the bot can see. This will send the numbers from 1 to 10 in the channel where the command was sent. If we send &quot;!count 5&quot;, this will send the numbers from 1 to 5 in the channel where the command was sent, etc...</p>
<p>If we send &quot;!count 10.5&quot;, this will raise an error because the argument <code>n</code> is of type <code>int</code> and &quot;10.5&quot; is not an integer. If we send &quot;!count abc&quot;, this will also raise an error because &quot;abc&quot; is not an integer. This is because discord.py use a system named <em>converters</em> to convert the arguments to the right type. We will see this later. (See <a href="chapter_2_commands/../chapter_3_basic_converters/basic_converter.html">basic converters</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-argument-commands"><a class="header" href="#multiple-argument-commands">Multiple argument commands</a></h1>
<p>To create commands with multiple arguments, we need to add arguments to the function. These arguments can be of any type except string. String are a special case and will be explained later. For example, if we want to create a command that takes two integers <code>a</code> and <code>b</code> as arguments and send the sum of <code>a</code> and <code>b</code>, we can do this:</p>
<pre><code class="language-py">@bot.command()
async def add(ctx : commands.Context, a : int, b : int):
    await ctx.send(a + b)
</code></pre>
<p>To call this command, we need to send &quot;!add 5 10&quot; (If the current prefix is &quot;!&quot; else change this with your prefix) in a channel where the bot can see. This will send &quot;15&quot; in the channel where the command was sent. If we send &quot;!add 10 20&quot;, this will send &quot;30&quot; in the channel where the command was sent, etc... So the final code will be:</p>
<pre><code class="language-py">&gt;&gt;&gt; !add 5 10
15
&gt;&gt;&gt; !add 10 20
30
&gt;&gt;&gt; !add &quot;Hello&quot; &quot;World&quot;
Command raised an exception: BadArgument: Converting to &quot;int&quot; failed for parameter &quot;a&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-argument-in-commands"><a class="header" href="#string-argument-in-commands">String argument in commands</a></h1>
<p>When we want to create a command that takes a string as an argument it do not work as expected. The naive implementation of a command that takes a string as an argument can be :</p>
<pre><code class="language-py">@bot.command()
async def echo(ctx : commands.Context, message : str):
    await ctx.send(message)
</code></pre>
<p>But if we call this command with &quot;!echo Hello World&quot;, this will only send &quot;Hello&quot; in the channel where the command was sent. This is because discord.py take each word as an argument. So &quot;Hello World&quot; is seen as two arguments: &quot;Hello&quot; and &quot;World&quot;. To fix this, we need to use the <code>*</code> operator named <em>keyword-only argument</em>. This operator will take all the remaining arguments as a single argument. So if we use this operator, the command will be:</p>
<pre><code class="language-py">@bot.command()
async def echo(ctx : commands.Context, *, message : str):
    await ctx.send(message)
</code></pre>
<p>Now if we call this command with &quot;!echo Hello World&quot;, this will send &quot;Hello World&quot; in the channel where the command was sent. This is because the <code>*</code> operator take all the remaining arguments as a single argument. So &quot;Hello World&quot; is seen as a single argument.</p>
<p>One thing to notice is that we can not add an argument after the string one because the <code>*</code> operator take all the remaining arguments as a single argument. So all others arguments need to be set before the <code>*</code> operator. For example if we want to create a command that takes a string as an argument and a number as an argument, we can do this:</p>
<pre><code class="language-py">@bot.command()
async def echo(ctx : commands.Context, n : int, *, message : str):
    for i in range(n):
        await ctx.send(message)
</code></pre>
<p>If we call this command with &quot;!echo 3 Hello World&quot;, this will send &quot;Hello World&quot; 3 times in the channel where the command was sent. So the final code will be:</p>
<pre><code class="language-py">&gt;&gt;&gt; !echo 3 Hello World
Hello World
Hello World
Hello World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unlimited-arguments-in-commands"><a class="header" href="#unlimited-arguments-in-commands">Unlimited arguments in commands</a></h1>
<p>discord.py let us create commands that takes a variable number of arguments. To do this, we need to use the <code>*args</code> argument in our command. This argument will take all the remaining arguments as a list. So if we use this argument, the command will be:</p>
<pre><code class="language-py">@bot.command()
async def sum(ctx : commands.Context, *args : int):
    await ctx.send(sum(args))
</code></pre>
<p>Now if we call this command with &quot;!sum 1 2 3 4 5&quot;, this will send &quot;15&quot; in the channel where the command was sent. This is because the <code>*args</code> argument take all the remaining arguments as a list. So &quot;1 2 3 4 5&quot; is seen as a list of 5 elements: [1, 2, 3, 4, 5].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands-error-handling"><a class="header" href="#commands-error-handling">Commands error handling</a></h1>
<p>Here is an example command :</p>
<pre><code class="language-py">@bot.command(name='welcome') 
async def welcome_command(ctx : commands.Context, member : discord.Member, n : int) -&gt; None:
    for _ in range(n):
        await ctx.send(f'Hello {member.mention}, welcome to guild {ctx.guild.name}, how are you ?')
</code></pre>
<p>This command is named &quot;welcome&quot; and take two arguments: a member and a number. This command will send &quot;Hello {member.mention}, welcome to guild {ctx.guild.name}, how are you ?&quot; n times in the channel where the command was sent. For example if we call this command with &quot;!welcome @user 3&quot;, this will send &quot;Hello @user, welcome to guild My Guild, how are you ?&quot; 3 times in the channel where the command was sent.</p>
<p>This commands seems to work but we can have a lot of problems with it. For example, the command can be called outside of a guild, the member may not exists or the number may not be an integer or may be negative. To fix this, we need to add some error handling.</p>
<p>To handle errors in discord.py we need to use the <code>@command_name.error</code> decorator. This decorator will be called if an error occurs in the command. This decorator take a function as an argument. This function will be called if an error occurs in the command. This function need to take two arguments: the first one is the context of the command and the second one is the error that occurred and it need to be <code>async</code>. We can name it as we want but it is recommended to name it <code>on_command_name_error</code> where &quot;command_name&quot; is the name of the command. For example, if we want to handle errors in the &quot;welcome&quot; command, we can do this:</p>
<pre><code class="language-py">@welcome_command.error
async def on_welcome_command_error(ctx : commands.Context, error : commands.CommandError) -&gt; None:
    pass
</code></pre>
<p>But first we need to raise some errors directly in the command. We need to check if the command is called outside of a guild, if the member exists and if the number is an integer and is positive. To do this, we can use the <code>ext.commands</code> module. This module contains all the errors that can be raised in a command. For example, if we want to check if the command is called outside of a guild and if the number is correct, we can do this:</p>
<pre><code class="language-py">@bot.command(name='new_welcome')
async def new_welcome_command(ctx : commands.Context, member : discord.Member, n : int) -&gt; None:
    if ctx.guild is None:
        raise commands.GuildNotFound('This command can only be used in a guild')
    
    if n &lt; 0 or not isinstance(n, int):
        raise commands.BadArgument
    
    for _ in range(n):
        await ctx.send(f'Hello {member.mention}, welcome to guild {ctx.guild.name}, how are you ?')
</code></pre>
<p>And now to handle these errors, we can do this:</p>
<pre><code class="language-py">@new_welcome_command.error
async def on_new_welcome_command_error(ctx : commands.Context, error : commands.CommandError):
    if isinstance(error, commands.GuildNotFound):
        return await ctx.send('This command can only be used in a guild')
    elif isinstance(error, commands.MissingRequiredArgument):
        return await ctx.send('You need to specify a member and a number')

    elif isinstance(error, commands.BadArgument):
        return await ctx.send('There is a problem with the arguments')
    elif isinstance(error, commands.MemberNotFound):
        return await ctx.send('The member was not found')
        
    # If the error is not handled, we need to raise it otherwise the error will be ignored
    raise error
</code></pre>
<p>Now if we call this command with &quot;!new_welcome @user 3&quot;, this will send &quot;Hello @user, welcome to guild My Guild, how are you ?&quot; 3 times in the channel where the command was sent. But if we call this command with &quot;!new_welcome @user -3&quot;, this will send &quot;There is a problem with the arguments&quot; in the channel where the command was sent. And if we call this command with &quot;!new_welcome&quot;, this will send &quot;You need to specify a member and a number&quot; in the channel where the command was sent.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converters"><a class="header" href="#converters">Converters</a></h1>
<p>In Python we do not really need to specify the type of a variable. We can just do <code>a = 1</code> and Python will know that <code>a</code> is an integer. However, in some cases, we need to specify the type of a variable. For example, when we are creating a function that takes a parameter, we need to specify the type of that parameter. This is called <strong>type hinting</strong>. For example, if we want to create a function that takes an integer as a parameter, we can do:</p>
<pre><code class="language-py">def add(a : int):
    return a + 1
</code></pre>
<p>In this example, we are creating a function that takes an integer <code>a</code> as a parameter and return <code>a + 1</code>. This is called <strong>type hinting</strong>. This is useful for the developer to know what type of data the function takes as a parameter. However, this is not useful for the user of the function. But in native Python this is only used for documentation. However, in discord.py, this is used to convert the user input to the type specified in the function. This is called <strong>converters</strong>.</p>
<p>In this chapter, we will see how to use the native Python type hinting to create converters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-converter"><a class="header" href="#basic-converter">Basic Converter</a></h1>
<p>Sometimes we just want to accept one type for a parameter. In Python, we can use the typing module to specify the type of a parameter but it is just used for type hinting and does not actually restrict the type of the parameter. In discord.py there are converters that can be used to restrict the type of a parameter. For example, if we want to add two numbers like :</p>
<pre><code class="language-py">@bot.command()
async def add(ctx : commands.Context, a : int, b : int):
    await ctx.send(a + b)
</code></pre>
<p>We can see the usage of the int converter. When we will call this commands all the parameters will be converted to int before being passed to the function. If we pass a string that cannot be converted to an int, the command will not be called and an error will be raised. This notation work for all the native types in Python.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cogs"><a class="header" href="#cogs">Cogs</a></h1>
<p>When our bot start to get bigger, we will need to split our code into multiple classes. To do that, we will need to create a new class that will inherit from commands.Cog. In this class, we will load all the commands that we want to use in the setup function. This is used to better organize the code and group related functionality together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-bot-setup"><a class="header" href="#advanced-bot-setup">Advanced Bot Setup</a></h1>
<p>When our bot start to get bigger, we will need to split our code into multiple Cogs and to do that, we will need to create a new class that will inherit from commands.Bot. In this class, we will load all the Cogs that we want to use in the setup_hook function.</p>
<pre><code class="language-py">import discord
from discord.ext import commands

class MyBot(commands.Bot):
    def __init__(self):
        super().__init__(
        command_prefix='!',
        intents=discord.Intents.all()
        )

    async def setup_hook(self) -&gt; None: # Method called before the `on_ready` event
        # This line setup all the slash commands
        await self.tree.sync()

    async def on_ready(self):
        print('-------------')
        print(f'Logged in as {self.user}')
        print(f'Bot is ready.')

bot = MyBot()
bot.run('token')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-cogs-work"><a class="header" href="#how-cogs-work">How Cogs Work</a></h1>
<p>In the <strong>discord.py</strong> library, there is a concept called <em>Cog</em>. A <em>Cog</em> is a <em>class</em> that contains a set of <em>commands</em> and <em>listeners</em>. They are used to better organize the code and group related <em>functionality</em> together. Each <em>Cog</em> is created by inheriting from the <code>commands.Cog</code> class, so a <em>Cog</em> has the following structure:</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class CogName(commands.Cog):
    def __init__(self) -&gt; None:
        ...
</code></pre>
<p>Generally, a <em>parameter</em> is added to the <em>class's initialization</em> which is the <em>bot</em>, in order to directly use its <em>functionality</em> within the <em>Cog</em>. This gives us a complete syntax for a Cog:</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class CogName(commands.Cog):
    def __init__(self, bot: commands.Bot) -&gt; None:
        self.bot = bot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commands-in-cogs"><a class="header" href="#commands-in-cogs">Commands in Cogs</a></h1>
<p>To add a new <em>command</em> to a <em>Cog</em>, we will use the <code>@commands.command</code> decorator. In addition to the <em>context</em>, our command should take <code>self</code> as a parameter, like all commands within a <em>class</em>. So, it would be:</p>
<pre><code class="language-python">class ExampleCog(commands.Cog):
    def __init__(self, bot: commands.Bot) -&gt; None:
        self.bot = bot

    @commands.command()
    async def command_name(self, ctx: commands.Context, param1, ..., paramN):
        ...
</code></pre>
<p>Let's create a <code>echo</code> command that takes a <em>string</em> parameter and returns the same string. Here's an example:</p>
<pre><code class="language-python">class ExampleCog(commands.Cog):
    def __init__(self, bot: commands.Bot) -&gt; None:
        self.bot = bot

    @commands.command(name=&quot;echo&quot;)
    async def echo_message(self, ctx: commands.Context, *, message: str) -&gt; discord.Message:
        return await ctx.send(message)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-in-cogs"><a class="header" href="#events-in-cogs">Events in Cogs</a></h1>
<p>To create a new event (named listeners in Cogs), we will need to create a new function that will have the <code>@commands.Cog.listener()</code> decorator. This function will take a function as an argument. This function will be called when the event is triggered. For example, if we want to create a listener that will be called when a message is sent, we can do this:</p>
<pre><code class="language-py">class MyCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_message(self, message : discord.Message):
        print(f'{message.author} sent a message.')
</code></pre>
<p>Now if we send a message in a channel where the bot can see, this will print the name of the author of the message in the console. But we can also set the name of the listener with the <code>name</code> argument of the decorator. For example, if we want to create a listener that will be called when a message is sent, we can do this:</p>
<pre><code class="language-py">class MyCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.Cog.listener(name='on_message')
    async def my_listener(self, message : discord.Message):
        print(f'{message.author} sent a message.')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embeds"><a class="header" href="#embeds">Embeds</a></h1>
<p>Embeds are a concept in Discord that allows us to send rich content in our messages. They are used to make our messages more appealing and to provide more information to the user. In this chapter, we will learn how to use embeds in our bots and how to customize them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-embeds-work"><a class="header" href="#how-embeds-work">How Embeds Work</a></h1>
<p>In the <em>discord.py</em> library, an <em>embed</em> is an <em>object</em> that allows displaying messages with more content and, most importantly, more visually appealing. An <em>Embed</em> uses the <code>discord.Embed</code> object, which takes three main optional <em>arguments</em>:</p>
<ul>
<li><code>color</code> represents the color that our <em>embed</em> will have once sent - this argument must take an object of type <code>discord.Color</code>.</li>
<li><code>title</code> represents the title of our <em>embed</em> and is of type <em>string</em>.</li>
<li><code>description</code> is also a <em>string</em> and represents the description that will be displayed once sent.</li>
</ul>
<p>In addition to that, each embed has a list of <em>methods</em> that allow adding additional elements =&gt; [[How to modify an embed in the discord.py library]].</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>An example of creating an <em>Embed</em> could be:</p>
<pre><code class="language-python">embed = discord.Embed(
    title=&quot;I am a title!&quot;,
    description=&quot;I am the description&quot;,
    color=discord.Color.green()
)
</code></pre>
<p>Once created, you can send it using the <em>method</em> <code>ctx.send(embed=embed)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embeds-configuration"><a class="header" href="#embeds-configuration">Embeds Configuration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slash-commands"><a class="header" href="#slash-commands">Slash Commands</a></h1>
<p>In the <em>discord.py</em> library, there are several types of <em>commands</em>. The simplest ones are the <em>regular commands</em> that are used with a predefined <em>prefix</em>. However, there is another type of command called <em>slash commands</em>. These commands are not called with a developer-defined <em>prefix</em> but with <code>/</code>, which triggers a menu where all our <em>slash commands</em> are listed.</p>
<p>These commands are extremely convenient because they are natively supported by Discord and provide a much more user-friendly interface. That's why it is recommended to use them instead of regular commands. Additionally, when calling a <em>slash command</em>, its parameters have predefined <em>types</em>, which helps avoid many errors, and their functioning eliminates the issue of <em>string parsing</em>.</p>
<p>To create a <em>slash command</em>, there are two ways: the first one is to use the <code>@bot.tree.command()</code> decorator, which is a method of the <code>command_tree</code> that handles all the <em>slash commands</em>. Another way to do it is by importing the <code>discord.app_commands</code> module and using the <code>app_commands.command()</code> decorator, which functions exactly the same as in the first case. A <em>slash command</em> will have one of the following structures:</p>
<pre><code class="language-python">from discord import app_commands

@bot.tree.command()
async def test_command(interaction: discord.Interaction):
    await interaction.response.send_message(&quot;test&quot;)

# or

@app_commands.command()
async def test_command(interaction: discord.Interaction):
    await interaction.response.send_message(&quot;test&quot;)
</code></pre>
<p>As we can see, there are some differences compared to <em>regular commands</em>. The two differences we see here are:</p>
<ul>
<li>Replacing <code>commands.Context</code> with <code>discord.Interaction</code>. <em>Slash commands</em> do not use a <em>context</em> but an <em>interaction</em>. The functioning of an <em>Interaction</em> is somewhat similar, excluding the details, but the <em>parameters</em> used to accomplish the same tasks are different.</li>
<li>Instead of using <code>ctx.send()</code> to send a message, we use <code>interaction.response.send_message()</code>. Its functioning is the same, with the only difference being that it can only be used once.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slash-commands-1"><a class="header" href="#slash-commands-1">Slash Commands</a></h1>
<p>In the <em>discord.py</em> library, there are several types of <em>commands</em>. The simplest ones are the <em>regular commands</em> that are used with a predefined <em>prefix</em>. However, there is another type of command called <em>slash commands</em>. These commands are not called with a developer-defined <em>prefix</em> but with <code>/</code>, which triggers a menu where all our <em>slash commands</em> are listed.</p>
<p>These commands are extremely convenient because they are natively supported by Discord and provide a much more user-friendly interface. That's why it is recommended to use them instead of regular commands. Additionally, when calling a <em>slash command</em>, its parameters have predefined <em>types</em>, which helps avoid many errors, and their functioning eliminates the issue of <em>string parsing</em>.</p>
<p>To create a <em>slash command</em>, there are two ways: the first one is to use the <code>@bot.tree.command()</code> decorator, which is a method of the <code>command_tree</code> that handles all the <em>slash commands</em>. Another way to do it is by importing the <code>discord.app_commands</code> module and using the <code>app_commands.command()</code> decorator, which functions exactly the same as in the first case. A <em>slash command</em> will have one of the following structures:</p>
<pre><code class="language-python">from discord import app_commands

@bot.tree.command()
async def test_command(interaction: discord.Interaction):
    await interaction.response.send_message(&quot;test&quot;)

# or

@app_commands.command()
async def test_command(interaction: discord.Interaction):
    await interaction.response.send_message(&quot;test&quot;)
</code></pre>
<p>As we can see, there are some differences compared to <em>regular commands</em>. The two differences we see here are:</p>
<ul>
<li>Replacing <code>commands.Context</code> with <code>discord.Interaction</code>. <em>Slash commands</em> do not use a <em>context</em> but an <em>interaction</em>. The functioning of an <em>Interaction</em> is somewhat similar, excluding the details, but the <em>parameters</em> used to accomplish the same tasks are different.</li>
<li>Instead of using <code>ctx.send()</code> to send a message, we use <code>interaction.response.send_message()</code>. Its functioning is the same, with the only difference being that it can only be used once.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slash-commands-in-cogs"><a class="header" href="#slash-commands-in-cogs">Slash Commands in Cogs</a></h1>
<p>In the previous chapter, we learned how to create <em>slash commands</em> in a <em>bot</em> that is not structured in <em>cogs</em>. However, if we want to use <em>slash commands</em> in a <em>bot</em> that is structured in <em>cogs</em>, we will have to use a different approach. In this chapter, we will learn how to create <em>slash commands</em> in a <em>bot</em> that is structured in <em>cogs</em>.</p>
<p>To create a <em>slash command</em> in a <em>bot</em> that is structured in <em>cogs</em>, we will have to use the <code>app_commands.command()</code> decorator. This decorator is used to create <em>slash commands</em> and is imported from the <code>discord.app_commands</code> module. The <code>app_commands.command()</code> decorator is used in the same way as the <code>bot.tree.command()</code> decorator, but it is used in a <em>cog</em> instead of a <em>bot</em>. So an example of a <em>slash command</em> in a <em>cog</em> would be:</p>
<pre><code class="language-python">from discord.ext import commands
from discord import app_commands

class SlashCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @app_commands.command()
    async def test_command(self, interaction: discord.Interaction):
        await interaction.response.send_message(&quot;test&quot;)
</code></pre>
<p>As we can see, the only difference between a <em>slash command</em> in a <em>bot</em> and a <em>slash command</em> in a <em>cog</em> is the decorator used to create it. However, there is one more thing we need to do to make our <em>slash commands</em> work. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid-commands"><a class="header" href="#hybrid-commands">Hybrid Commands</a></h1>
<p>Sometimes we want to have a command that can be used both as a <em>regular command</em> and as a <em>slash command</em>. This is possible thanks to the <code>hybrid_command()</code> decorator, which is imported from the <code>discord.ext.commands</code> module. With this decorator we do not have the <em>Interaction</em> object, so we will have to use the <em>context</em> object. An example of a <em>hybrid command</em> would be:</p>
<pre><code class="language-python">from discord.ext import commands

@commands.hybrid_command()
async def test_command(self, ctx: commands.Context):
    await ctx.send(&quot;test&quot;)
</code></pre>
<p>As we can see, the only difference between a <em>regular command</em> and a <em>hybrid command</em> is the decorator used to create it. Now to call this command we just have to use the prefix or the slash command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid-commands-1"><a class="header" href="#hybrid-commands-1">Hybrid Commands</a></h1>
<p>Sometimes we want to have a command that can be used both as a <em>regular command</em> and as a <em>slash command</em>. This is possible thanks to the <code>hybrid_command()</code> decorator, which is imported from the <code>discord.ext.commands</code> module. With this decorator we do not have the <em>Interaction</em> object, so we will have to use the <em>context</em> object. An example of a <em>hybrid command</em> would be:</p>
<pre><code class="language-python">from discord.ext import commands

@commands.hybrid_command()
async def test_command(self, ctx: commands.Context):
    await ctx.send(&quot;test&quot;)
</code></pre>
<p>As we can see, the only difference between a <em>regular command</em> and a <em>hybrid command</em> is the decorator used to create it. Now to call this command we just have to use the prefix or the slash command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid-commands-in-cogs"><a class="header" href="#hybrid-commands-in-cogs">Hybrid Commands in Cogs</a></h1>
<p>To create a <em>hybrid command</em> in a <em>bot</em> that is structured in <em>cogs</em>, we will have to use the <code>hybrid_command()</code> decorator. This decorator is used to create <em>hybrid commands</em> and is imported from the <code>discord.ext.commands</code> module. The <code>hybrid_command()</code> decorator is used in the same way as the <code>bot.command()</code> decorator, but it is used in a <em>cog</em> instead of a <em>bot</em>. So an example of a <em>hybrid command</em> in a <em>cog</em> would be:</p>
<pre><code class="language-python">from discord.ext import commands

class HybridCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.hybrid_command()
    async def test_command(self, ctx: commands.Context):
        await ctx.send(&quot;test&quot;)
</code></pre>
<p>So as we can see it works the same way as a <em>hybrid command</em> in a <em>bot</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converters-1"><a class="header" href="#converters-1">Converters</a></h1>
<p>As we saw in the chapter 3 about <a href="chapter_8_converters/../chapter_3_basic_converters/basic_converters.html">basic converters</a>, we can use the native Python type hinting to create converters. However, this is not the only way to create converters. In this chapter, we will see how to create converters using functions, and how to create advanced converters. We will also see how to use the converters provided by discord.py.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-converter"><a class="header" href="#function-converter">Function Converter</a></h1>
<p>We saw in the chapter 3 that we can use <em>Type Hints</em> to convert the arguments of a <em>command</em> to the type we want. However, sometimes we want to convert the arguments of a <em>command</em> to a type that is not supported by <em>Type Hints</em>. For example, we may want to convert the arguments of a <em>command</em> to a <em>function</em>. This is possible thanks to functions converters.</p>
<p>Let's take this command as an example:</p>
<pre><code class="language-python">@bot.command()
async def up(ctx : commands.Context, *, content : str) -&gt; discord.Message:
    await ctx.send(content.upper())
</code></pre>
<p>This command takes a string as an argument and sends it back in uppercase. However, we may want to convert the argument to a function instead of a string. We will create a new function that takes a string as an argument and returns it in uppercase.</p>
<pre><code class="language-python">def to_uppercase(string : str) -&gt; str:
    return string.upper()
</code></pre>
<p>And now instead of the <code>str</code> type hint, we will use the <code>to_uppercase</code> function.</p>
<pre><code class="language-python">@bot.command()
async def up(ctx : commands.Context, *, content : to_uppercase) -&gt; discord.Message:
    await ctx.send(content)
</code></pre>
<p>Now when we call the command, the argument will be converted to a function instead of a string. If we call the command with the argument <code>test</code>, the bot will send <code>TEST</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; !up test
TEST
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-converter"><a class="header" href="#advanced-converter">Advanced Converter</a></h1>
<p>If we want some more advanced Converters it is possible to create custom converters class that inherit from <code>discord.ext.commands.Converter</code> or another subclass of <code>discord.ext.commands.Converter</code>. For example, we can create a converter that converts the argument to a <code>discord.Member</code> object. To do this we will create a class that inherits from <code>discord.ext.commands.Converter</code> and we will override the <code>convert()</code> method. This method takes two arguments: <code>ctx</code> and <code>argument</code>. The <code>ctx</code> argument is the <em>context</em> object and the <code>argument</code> argument is the argument to convert. This method must return the converted argument. So our converter will look like this:</p>
<pre><code class="language-python">from discord.ext import commands

class MemberConverter(commands.Converter):
    async def convert(self, ctx: commands.Context, argument: str) -&gt; discord.Member:
        return discord.utils.get(ctx.guild.members, name=argument)
</code></pre>
<p>To use this converter we will have to pass it as a type hint to the argument we want to convert.</p>
<pre><code class="language-python">@bot.command()
async def test(ctx: commands.Context, member: MemberConverter):
    await ctx.send(member.name)
</code></pre>
<p>Now when we call the command with the name of a member as an argument, the argument will be converted to a <code>discord.Member</code> object.</p>
<pre><code class="language-python">&gt;&gt;&gt; !test @member
member
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discord-converters"><a class="header" href="#discord-converters">Discord Converters</a></h1>
<p>Some of the decorators are so commonly used that they have been included in the <code>discord.py</code> library. These decorators are called <em>discord converters</em> and they are used to convert the arguments of a command into a specific type. We already saw some of them like <code>discord.Member</code> or <code>discord.Role</code>. To use them we will have to pass them as a type hint to the argument we want to convert. For example, if we want to convert the argument to a <code>discord.Member</code> object, we will have to pass <code>discord.Member</code> as a type hint to the argument.</p>
<pre><code class="language-python">@bot.command()
async def test(ctx: commands.Context, member: discord.Member):
    await ctx.send(member.name)
</code></pre>
<p>Now when we call the command with the name of a member as an argument, the argument will be converted to a <code>discord.Member</code> object.</p>
<pre><code class="language-python">&gt;&gt;&gt; !test @member
member
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
